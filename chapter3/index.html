<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title> Perlin Noise and Smooth Movers </title>

  
  <link rel="stylesheet" type="text/css" href="/Honours-website-project/assets/cssStyle/generic.css">
  <link rel="stylesheet" href="/Honours-website-project/assets/cssStyle/katex.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js" defer></script>
  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
</head>

<body>
 
  
<h1>Chapter 3</h1>
<h1>Perlin Noise and Smooth Movers</h1>
<hr>


  <h2>3.1 Phenomena</h2>
<ol>
<li>
<p>From above walkers, in case we want to simulate motion phenomena such that it is smooth - smooth being in terms of visual appearance - movement is not jerky / jagged - curvy / continuous.</p>
</li>
<li>
<p>We could constrain our normal walkers parameters further to do the trick - but end of the day</p>
<ul>
<li>It is still purely random numbers so one can still get a jerky turn - if first random value on one side and the next on the other</li>
<li>scaling down to small intervals may not be feasible - and don’t really need normal distribution at that point - use uniform only</li>
</ul>
</li>
<li>
<p>It might be a better idea to create a algorithm that produces random values that could be somewhat close to each other - when the input is also somewhat close to each other - by design choice - exactly what Perlin noise (henceforth referred to as PNoise) does [Perlin 02]</p>
</li>
<li>
<p>This has much more uses beyond smooth motion - any kind of animation requiring smoothness - a key part of <em>natural looking</em> phenomena</p>
<ul>
<li>Terrain - in a forest - trees not of same height - but overall neighboring trees will not be too different in height (assuming they are of similar species)</li>
<li>Textures - on stones - marbles, tiles, granite, etc. all have varying bright and dark areas - but changes gradually - no stone is half black and half white</li>
</ul>
</li>
</ol>
<h2>3.2 Modelling</h2>
<ul>
<li>
<p>PNoise (Perlin Noise) definition</p>
<ol>
<li>PNoise can be thought of as a function/algorithm that takes in N-dimensional input (co-ordinate) and returns a random value b/w <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span></eq> and <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></eq></li>
<li>PNoise generates a sequence of pseudo-random numbers that appear to be smoothly varying</li>
<li>i.e., given two inputs close to each other the output will also be close to each other</li>
<li>Different from noise / white noise - there samples are completely uncorrelated</li>
<li>It doesn’t add noisy-ness to existing data or smoothly interpolate between pre-existing noisy/random input.</li>
</ol>
</li>
<li>
<p>Such algs are called procedural noise functions - this is what we refer to when we say noise - other examples are Simplex noise, Value noise [ LSRD*10 ]</p>
</li>
<li>
<p>Perlin noise is a type of lattice gradient noise</p>
<ol>
<li>Define some random objects (mostly values or vectors) over a subset of the given space</li>
<li>For an input point identify the neighbouring points from subset (lattice)</li>
<li>Interpolate a value from the random objects with some weighted function</li>
</ol>
</li>
<li>
<p>Perlin noise in 2D specifically uses:</p>
<ol>
<li>Integer lattice grid and the random objects are gradient vectors - 4 unique vectors<sup>1</sup> - randomly arranged throughout lattice</li>
<li>Then first we calculate the values to interpolated as:
<ol>
<li>dot ( vector at lattice point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq>, difference vector from lattice point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></eq> )</li>
<li>Interpolate between these values - in two stages - first along <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>-axis, then <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>-axis, where weight of each value is the distance of the lattice point from the given point - distance here just being the <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>-component in first stage and <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> - component in second</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2>3.3 Implementation</h2>
<h3>3.3.1 Implementation of the perlin noise algorithm</h3>
<p>Random arrangement of the vectors:</p>
<ul>
<li>A predefined array of permuted numbers (0-255) <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> and an array of 4 vectors - <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></eq> - where each vector is the vector pointing from origin to one corner of the unit square.<sup>2</sup></li>
<li>Now for each lattice point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>Z</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x,y) \in Z^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">Z</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> - ( Actually just <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0...255</mn><msup><mo stretchy="false">}</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\{0...255\}^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0...255</span><span class="mclose"><span class="mclose">}</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> ), we assign the vector <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mtext>’</mtext><mo stretchy="false">[</mo><mi>x</mi><mo>+</mo><mi>P</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">G’[ x + P[y]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">G</span><span class="mord">’</span><span class="mopen">[</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]]</span></span></span></span></eq> - that is the <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>+</mo><mi>P</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo><msup><mo stretchy="false">)</mo><mrow><mi>t</mi><mi>h</mi></mrow></msup></mrow><annotation encoding="application/x-tex">(x + P[y])^{th}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0991em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></eq> element of <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding="application/x-tex">G’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord">’</span></span></span></span></eq>, where <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding="application/x-tex">G’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord">’</span></span></span></span></eq> is just the array <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">G</span></span></span></span></eq> repeated till it is the size of <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq>. But note that adding <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>+</mo><mi>P</mi><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">x + P[y]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">]</span></span></span></span></eq> may be greater than <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>255</mn></mrow><annotation encoding="application/x-tex">255</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">255</span></span></span></span></eq>, but is less than <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>512</mn></mrow><annotation encoding="application/x-tex">512</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">512</span></span></span></span></eq> - therefore we’ll just double our <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding="application/x-tex">G’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord">’</span></span></span></span></eq> and <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> arrays- repeating their elements.</li>
</ul>
<p>The choice of the particular <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq> array - is arbitrary - made by Perlin, after some randomisation and a visual output that was enough for his purposes. Though modern implementations come with a seeding option to generate a different permutation list.<br>
But an important characteristic is that for a given seed, every lattice point will also have the same vector assigned to it</p>
<p>Noise value at any <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>∈</mo><msup><mi>R</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x,y) \in R^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> implemented in <strong>jS</strong> as follows:</p>
<pre tabindex="0" class="code-block"><code class="language-js">module<span class="token punctuation">.</span><span class="token function-variable function">perlin2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Find unit grid cell containing point</span>
  <span class="token keyword">let</span> <span class="token constant">X</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">Y</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Get relative xy coordinates of point within that cell</span>
  x <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token constant">X</span><span class="token punctuation">;</span> y <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token constant">Y</span><span class="token punctuation">;</span>
  <span class="token comment">// Wrap the integer cells at 255 (smaller integer period can be introduced here)</span>
  <span class="token constant">X</span> <span class="token operator">=</span> <span class="token constant">X</span> <span class="token operator">&amp;</span> <span class="token number">255</span><span class="token punctuation">;</span> <span class="token constant">Y</span> <span class="token operator">=</span> <span class="token constant">Y</span> <span class="token operator">&amp;</span> <span class="token number">255</span><span class="token punctuation">;</span>


  <span class="token comment">// Calculate noise contributions from each of the four corners</span>
  <span class="token keyword">let</span> n00 <span class="token operator">=</span> gradP<span class="token punctuation">[</span><span class="token constant">X</span><span class="token operator">+</span>perm<span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">dot2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> n01 <span class="token operator">=</span> gradP<span class="token punctuation">[</span><span class="token constant">X</span><span class="token operator">+</span>perm<span class="token punctuation">[</span><span class="token constant">Y</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">dot2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> n10 <span class="token operator">=</span> gradP<span class="token punctuation">[</span><span class="token constant">X</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>perm<span class="token punctuation">[</span><span class="token constant">Y</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">dot2</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> n11 <span class="token operator">=</span> gradP<span class="token punctuation">[</span><span class="token constant">X</span><span class="token operator">+</span><span class="token number">1</span><span class="token operator">+</span>perm<span class="token punctuation">[</span><span class="token constant">Y</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">dot2</span><span class="token punctuation">(</span>x<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> y<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token comment">// Compute the fade curve value for x</span>
  <span class="token keyword">let</span> u <span class="token operator">=</span> <span class="token function">fade</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>


  <span class="token comment">// Interpolate the four results</span>
  <span class="token keyword">return</span> <span class="token function">lerp</span><span class="token punctuation">(</span>
      <span class="token function">lerp</span><span class="token punctuation">(</span>n00<span class="token punctuation">,</span> n10<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">lerp</span><span class="token punctuation">(</span>n01<span class="token punctuation">,</span> n11<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token function">fade</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>This code can be viewed at the GitHub repo for this project <a href="https://github.com/beeezal/Honours-project-codes/blob/release/thesis-examples/NoiseExamples/noise.js">here</a>. This contains the defintion of all the other components - such as linear interpolation, ease function, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mtext>’</mtext></mrow><annotation encoding="application/x-tex">G’</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">G</span><span class="mord">’</span></span></span></span></eq>.<sup>3</sup></p>
<ul>
<li>
<p>Explaining some implementation choices:</p>
<ol>
<li>The use of <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>256</mn></mrow><annotation encoding="application/x-tex">256</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">256</span></span></span></span></eq> as our choice of array size, allows us to not use modular arithmetic (which is costly in terms of computation), but we can just use bit operators, because $255 = 1111111_2 $</li>
<li>Why are our vectors gradient vectors - because the value of dot product gives information about how aligned we are to the vector at that point - more alignment greater is the value - i.e. the vectors point to the direction in which the values increase the most - definition of gradient vectors of a function in calculus.</li>
<li>Explaining the fade/ease function - avoids sharp artefacts at the lattice points - i.e. reaches 0 linearly - looks unappealing and obvious that it is indeed a lattice point.</li>
<li>Ease function basically gives lower weight to the value when we are close to the particular lattice point and more when we are towards the center.</li>
</ol>
</li>
<li>
<p>Note, what we are doing is defining noise within the <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>256</mn><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">256^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">25</span><span class="mord"><span class="mord">6</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></eq> lattice - and extending that to rest of the cartesian plane - this works because the interval is large enough before repeating - this is also why in actual examples we will not use the coordinate point <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x,y)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span></span></span></span></eq> exactly - but either scale it down to a smaller number or run it through a function - hence on larger surfaces still not see the repeating pattern easily</p>
</li>
</ul>
<h3>3.3.2 Implementation of the perlin noise walker</h3>
<p>Rand_func:<br>
<code>noise(val)</code> - produces 1D perlin Noise value4</p>
<p>Applied parameters:</p>
<ul>
<li>
<p>Location - directly through x, y coordinates of position</p>
<p>range:  <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x \in [0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span></span></span></span></eq>, width of screen <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span></span></span></span></eq>, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>∈</mo><mo stretchy="false">[</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">y \in [0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span></span></span></span></eq>, height of screen <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">]</span></span></span></span></eq>,</p>
</li>
<li>
<p>Direction, directly through <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x, y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> coordinates of velocity,</p>
<p>range = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>3</mn><mo separator="true">,</mo><mn>3</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(-3, 3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">3</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">3</span><span class="mclose">)</span></span></span></span></eq></p>
</li>
<li>
<p>Velocity (both magnitude and direction)</p>
<p>range:</p>
<ul>
<li>mag $ \in (0,$  diameter <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">/2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">/2</span><span class="mclose">)</span></span></span></span></eq>,</li>
<li>direction <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\in (-1,1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></eq></li>
</ul>
</li>
</ul>
<pre tabindex="0" class="code-block"><code class="language-js"><span class="token comment">/* Code for a 2D RW that is manupilated according to perlin noise.
Walk is performed by picking a noise value separately for the x-coord and y-coord
Hereafter noise value will be referred as n-value*/</span>

<span class="token keyword">class</span> <span class="token class-name">Walker</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Setting class fields - offests for each co-ordinate (starting point in time for the noise function)
  x and y offests are always increased and z offest only when step() affecting_parameter is 'step'*/</span>
  xoff <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  yoff <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>      <span class="token comment">////Note that the difference is arbitrary, but it is important,</span>
  zoff <span class="token operator">=</span> <span class="token number">2000</span><span class="token punctuation">;</span>      <span class="token comment">//in order to avoid co-orrelation between each direction (in a given time t)</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>r</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>r <span class="token operator">=</span> r<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//Displays the walker at the current location with a circle of radius r</span>
    <span class="token function">stroke</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">circle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">step</span><span class="token punctuation">(</span>affecting_params<span class="token operator">=</span><span class="token string">'direction'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//Switch statement to determine the which parameter is being affected. Default: direction</span>
    <span class="token comment">//All of them are affected by Perlin noise</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>affecting_params<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token comment">// Changing the direction in which the walker is moving</span>
      <span class="token keyword">case</span> <span class="token string">'direction'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>xoff<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span>     <span class="token comment">//map() scales n-value to (-1,1) from (0,1) - Enabling RW to move in all directions</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>yoff<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">;</span>     <span class="token comment">//3 is the maginitude of the step. An arbitrary standard accross all RW methods</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token comment">// Directly changing the location of the walker</span>
      <span class="token keyword">case</span> <span class="token string">'location'</span><span class="token operator">:</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>xoff<span class="token punctuation">)</span><span class="token operator">*</span>width<span class="token punctuation">;</span>                <span class="token comment">//noise(t)*k - scales n-value to (0,k) from (0,1)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>yoff<span class="token punctuation">)</span><span class="token operator">*</span>height<span class="token punctuation">;</span>               <span class="token comment">//Therefore here x-values are (0,width) and y-values are (0,height)</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      
      <span class="token comment">// Changing both step size and direction</span>
      <span class="token keyword">case</span> <span class="token string">'step'</span><span class="token operator">:</span>
        <span class="token keyword">let</span> vel_mag <span class="token operator">=</span> <span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>zoff<span class="token punctuation">)</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>r<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">+=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>xoff<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>vel_mag<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">+=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">noise</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>yoff<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>vel_mag<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>zoff <span class="token operator">+=</span> <span class="token number">0.01</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>xoff <span class="token operator">+=</span> <span class="token number">0.01</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>yoff <span class="token operator">+=</span> <span class="token number">0.01</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> w<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">createCanvas</span><span class="token punctuation">(</span>windowWidth<span class="token punctuation">,</span> windowHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">background</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  w <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Walker</span><span class="token punctuation">(</span>width<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> height<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">draw</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Be aware of which function you call first according to the step type you chose</span>
  w<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             
  w<span class="token punctuation">.</span><span class="token function">step</span><span class="token punctuation">(</span><span class="token string">'direction'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> </code></pre>
<p>A simulation of a similar implementation of the Perlin Noise walker is added to the 4<sup>th</sup> chapter, in section <a href="">4.3.4</a></p>
<h2>Notes:</h2>
<ol>
<li>
<p>This is in the improved Perlin noise - made in 2002, the original noise implementation (introduced 1984) has a set of 256 randomly generated vectors - and there are other changes that were made to the implementation. Perlin further made even more improvements to the implementation, by changing the definition grid structure and introduced a new algorithm - Simplex noise.<br>
Because the idea of the algorithm is more important than any specific implementation for the purposes of this thesis, these differences are omitted from discussion</p>
</li>
<li>
<p>An advantage of this choice is - neighbouring grids will not end up being too similar - which would cause a large area of very similar values.</p>
</li>
<li>
<p>Note that this is a native JS implementation hence not written using <strong>p5</strong> functions. And the implemented function for Perlin noise in <strong>p5.js</strong> called <code>perlin()</code> is a different noise algorithm (value noise) which is what we use in <a href="#3.3.2-implementation-of-the-perlin-noise-walker">3.3.2</a> for our Perlin Walker. But this doesn’t the output much, as implementations of both noises in 1D are similar.</p>
</li>
<li>
<p>1D PNoise works analogous to how 2D PNoise was explained above - in fact <strong>p5.js</strong> implementation and actual implementation of 1D PNoise works the same way.</p>
</li>
</ol>



<!-- Auto-load section scripts -->
<!-- Although there are no scripts in this chapter as of now -->
<!-- leaving the below code as a placeholder for future use -->

  <script src="."></script>


</body>
</html>