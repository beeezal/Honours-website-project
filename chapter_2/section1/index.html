
<html><head></head><body><h2>2.1 Phenomena</h2>
<p>Attempting to capture the randomness we see around us in a finatry, computational world is of deep interest. This does not disclude motion simulation. From trying to parameterize microbial environments to understand motion of bacteria<sup>1</sup>, to creating a background scene of moths swarming around a light source in the night, the ability to produce randomness (or more precisely <em>pseudo-randomness</em>) is of vast use from the microscopic to the macroscopic world.</p>
<p>In motion phenomena, when one does not know of all the conditions that lead to a certain outcome, or one simply cannot model all the parameters - randomness is often introduced as a substitute. For example: modelling passing of genetics from parents. It is usually modelled as randomized selection of traits from either parent and changing the traits by slight perturbations - a substitute for evolution.</p>
<p>Therefore modelling and understanding how randomness is simulated is a crucial step in moving towards more complex natural phenomena. In this project, we will do this by trying to simulate different kinds of random walks - with varying underlying distributions and parameters.</p>
<h2>2.2 Modelling</h2>
<p>All things related to representation and motion will remain the same in terms of modelling for this chapter (and the remainder of the project). The only difference of a <em>deterministic</em> motion phenomena to a <em>stochastic</em> one, is that the position of our mover (or ‚Äòwalker‚Äô in this chapter) will be updated randomly - according to some probability distribution, as compared to external forces in the environment.<sup>2</sup> Therefore the <code>update()</code> method now will look like</p>
<pre><code>update(){  
    applied quantity = rand_function(p1, p2,...)   
    // Do calculations to go from applied quantity to position  
      
   new pos = ùëì( applied quantity [, old pos] )  
}
</code></pre>
<p>Here, rand_func is either a built-in function - in <strong>JS</strong>, the <strong>p5</strong> library^3 4^, or a function made by ourselves  that samples from particular probability distribution. The applied quantity, is either magnitude or direction of the next step which can be modelled as a velocity vector but not always done so.</p>
<p><strong>Direction</strong>: then the angle is randomly generated and we derive velocity from the angle, with some set magnitude.<br>
<strong>Magnitude</strong>: then the x-coordinates and y-coordinates are randomly generated and added to the current position. Or randomly generate a scalar value to be multiplied to a given velocity</p>
<p>Of course, affecting one parameter of motion usually affects the other and a random walk with constant direction but varying magnitude is not useful (unless in 1D). Hence, picking x and y coords would also usually ensure the direction changes as well. Hence, it is through combining them with different distributions and/or varying them separately (like constant magnitude and varying direction) we create different simulations of a random walk.</p>
<h2>2.3 Implementation</h2>
<h3>2.3.1 Basic random walker</h3>
<p>The basic walker is implemented without vectors, and hence, just adding changes to the current position each frame is how we implement it. The change is precisely what our applied quantity is and the random distribution is, uniform over the unit-square.</p>
<p>The rand_func here is <code>random(a,b)</code> returns a uniformly distributed sample from the range (a,b)</p>
<pre><code class="language-js">/* A 2D random walk performed by a point object on a screen (Random Walker)
The Probability distribution taken for the RW is Uniform(-1,1) - separately for the x-value and y-value*/

class Walker {
  //This is the class for the RW
  constructor() {
    //we are placing the walker at the center of the screen
    this.x = width / 2;
    this.y = height / 2;
  }

  display() {
    //Displays the walker at the given location
    stroke(0);
    point(this.x, this.y);
  }

  update() {
    //Changes the location of the walker randomly within a unit square of the current location
    this.x += random(-1, 1);
    this.y += random(-1, 1);
  }
}

let w;

//Global functions inbuilt in p5.js, setup() runs once and draw() runs repeatedly
/*The setup() function is used to define the initial environment properties such as screen size and background color
and creating any objects required in the programme*/
function setup() {
  createCanvas(700, 500);
  //Creating an instance 'w' of the of the class Walker
  w = new Walker();   
  background(255);
}

/*The draw() function is called repeatedly in a infinte loop. It is used to animate the objects in the canvas,
by repeatedly changing the properties of the object every frame*/
function draw() { 
  w.display();
  w.update();
}
</code></pre>
<p>And this is the output simulation</p>
<div class="simulation-container">
  <div id="sec1" class="interactive-sketch"></div>
  <div id="interactive-controls-sec1" class="interactive-panel"></div>
  <div class="control-buttons">
    <button onclick="pauseButtonToggle(this, sec1Sketch);">Play</button> 
    <button onclick="sec1Sketch.initializeSketch();">Reset</button>
  </div>
</div></body></html>
